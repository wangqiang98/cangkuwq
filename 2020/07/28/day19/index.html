<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>day19 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="递归递归在编程世界中的表现就是函数自己调用自己。 递归在数学中的应用大家还记得在高中学的阶乘的计算么? 比如:n! &#x3D; 1 * 2 * 3 * 4 * …… * (n-1) * n循环实现大家利用现在的循环知识，如何实现呢?代码如下 12345678910111213141516package com.youkeda;public class Recursive &amp;#123;  public st">
<meta property="og:type" content="article">
<meta property="og:title" content="day19">
<meta property="og:url" content="http://yoursite.com/2020/07/28/day19/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="递归递归在编程世界中的表现就是函数自己调用自己。 递归在数学中的应用大家还记得在高中学的阶乘的计算么? 比如:n! &#x3D; 1 * 2 * 3 * 4 * …… * (n-1) * n循环实现大家利用现在的循环知识，如何实现呢?代码如下 12345678910111213141516package com.youkeda;public class Recursive &amp;#123;  public st">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://qgt-document.oss-cn-beijing.aliyuncs.com/PY1/10/%E6%B1%89%E8%AF%BA%E5%A1%94.png">
<meta property="og:image" content="https://style.youkeda.com/img/course/a1/5/1-1.svg">
<meta property="og:image" content="https://qgt-document.oss-cn-beijing.aliyuncs.com/PY1/9/%E6%B1%89%E8%AF%BA%E5%A1%942%E5%B1%82.gif">
<meta property="og:image" content="https://qgt-document.oss-cn-beijing.aliyuncs.com/PY1/9/%E6%B1%89%E8%AF%BA%E5%A1%943%E5%B1%82.gif">
<meta property="og:image" content="https://qgt-document.oss-cn-beijing.aliyuncs.com/PY1/10/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.png">
<meta property="og:image" content="https://style.youkeda.com/img/course/a1/5/4-1.svg">
<meta property="og:image" content="https://style.youkeda.com/img/course/a1/5/4-2.svg">
<meta property="og:image" content="https://style.youkeda.com/img/course/a1/5/5-2.svg">
<meta property="og:image" content="https://style.youkeda.com/img/course/a1/5/5-3.svg">
<meta property="og:image" content="https://style.youkeda.com/img/course/a1/5/5-4.svg">
<meta property="og:image" content="https://style.youkeda.com/img/course/a1/5/5-5.svg">
<meta property="og:image" content="https://style.youkeda.com/img/course/a1/5/5-6.svg">
<meta property="og:image" content="https://style.youkeda.com/img/course/a1/5/5-7.svg">
<meta property="article:published_time" content="2020-07-28T14:02:53.000Z">
<meta property="article:modified_time" content="2020-07-30T01:54:01.410Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="递归、分治思想-归并排序、快速排序、快速选择">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qgt-document.oss-cn-beijing.aliyuncs.com/PY1/10/%E6%B1%89%E8%AF%BA%E5%A1%94.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-day19" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/28/day19/" class="article-date">
  <time datetime="2020-07-28T14:02:53.000Z" itemprop="datePublished">2020-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      day19
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><strong>递归</strong>在编程世界中的表现就是<strong>函数自己调用自己</strong>。</p>
<h3 id="递归在数学中的应用"><a href="#递归在数学中的应用" class="headerlink" title="递归在数学中的应用"></a>递归在数学中的应用</h3><p>大家还记得在高中学的阶乘的计算么? 比如:<br><strong>n! = 1 * 2 * 3 * 4 * …… * (n-1) * n</strong><br><strong>循环实现</strong><br>大家利用现在的循环知识，如何实现呢?代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.youkeda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recursive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> factorial = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      factorial *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> factorial;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(factorial(<span class="number">10</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><p>如果用递归思想，应该怎么实现呢?我们对上面的公式简化下，如果用数学表达公式来表示，可以简单理解为：<br><strong>f(1) = 1</strong><br><strong>f(n) = f(n-1) * n</strong><br>我们来分析下这个公式强调的概念。首先<strong>f(1) = 1</strong>这个就不用多说，当<strong>n= 1</strong>时,结果是<br>重点理解下<strong>f(n) = f(n-1)*n</strong>，这其实就是一种递归的概念，我们为了求<strong>f(n)</strong>，我们不需要关心其他的，我们只需要知道，它是在f(n-1) 的基础 上在乘以n就可以得到。</p>
<p>换一句话说: .我们在求<strong>f(n</strong>)的时候， 我们假设已经搞定 <strong>f(n-1)</strong>了，我们只需要考虑在<strong>f(n-1)</strong> 基础上所需要增加的操作。</p>
<p>那如何用代码来实现呢</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.youkeda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recursive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//#1. 当 n = 1 时，递归结束</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//#2. 把 factorial(n - 1) 的结果和 n 相乘，剩下的交给 factorial(n - 1) 来解决。</span></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(factorial(<span class="number">10</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="汉诺塔的问题"><a href="#汉诺塔的问题" class="headerlink" title="汉诺塔的问题"></a>汉诺塔的问题</h4><p>汉诺塔问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上<br>按照大小顺序摞着64片黄金盘。大梵天命令婆罗门]把圆从下开始按大小顺序重新摆放在另一根柱子上。齟规定，在小圆盘上坏能放大圆盘，在三根柱子之间- -次只能移动一个圆盘。</p>
<p><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/PY1/10/%E6%B1%89%E8%AF%BA%E5%A1%94.png" alt></p>
<p>如上图所示，为了显示方便，我们把圆盘减少到5个。现在要求庙里的老和尚把这64个全部移动到第三个柱子上。<br>一、此时老和尚(后面我们叫他第1个和尚)，这也太难 了吧!所以他想:<br>1.我把上面的63个盘子视为一个整体，让我徒弟(第2个和尚)把这63个盘子移动到第二根柱子上(这个过程包含很多步)<br>2.完成后叫我一声，我把最后一个盘子移动到第三个柱子上<br>3.再让我徒弟把63个盘子移动到第三个柱子上(这个过程包含很多步)，我的任务就完成了<br>●在这里对第一个和尚来说，只有两个盘子，上面的盘子是1-63层，反正是徒弟实现的，怎么实现，作为师傅的不管<br>●移动63个盘子是很大的工作量，我们接下来会一步步拆解</p>
<p>二、此时第二个和尚懵逼了，师傅你怕不是在逗我?还好我也有徒弟，于是他叫来他徒弟(我们把他叫为第3个和尚)， 他有样学样对他徒弟说:<br>1.你把前面62个盘子移动到第三个柱子上(这个过程包含很多步)<br>2.完成后叫我一声，我把倒数第2个盘子移动到第二个柱子上<br>3.然后你再把第三个柱子的62个盘子移动到第二个柱子上(这个过程包含很多步)<br>4.然后第二个柱子上已经有63个盘子，我再去找师傅，告诉他我完成了任务<br>5.最后师傅让我把63个盘子移动到第三个柱子，我又来找我的徒弟了<br>6.第3个徒弟，你把62个盘子移开，放到第一个柱子上<br>7.我把倒数第2个盘子移动到第三个柱子上<br>8.第3个徒弟，再把62个盘子移动到第三个柱子上。在这里对第二个和尚来说，只贿两个盘子，上面到盘子 是1-62层，反正是徒弟实现的，作为师傅的不管,最下面那个盘子是师傅(第1个和尚)移动的，他也不管接下来就比较简单了。</p>
<p>当第64个和尚移动第1个盘子,把它移开,然后第63个和尚移动他自己的任务，以此类推。</p>
<p><img src="https://style.youkeda.com/img/course/a1/5/1-1.svg" alt></p>
<p>这就是递归思维。<br><strong>实战缩减版场景</strong><br>我们再来图际一下这个任务，首先是两个盘子的情况:</p>
<p><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/PY1/9/%E6%B1%89%E8%AF%BA%E5%A1%942%E5%B1%82.gif" alt></p>
<p>我们可以看到一共移动了3次盘子，也就是2^2-1<br>然后是3个盘子的情况:</p>
<p><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/PY1/9/%E6%B1%89%E8%AF%BA%E5%A1%943%E5%B1%82.gif" alt></p>
<p>我们可以看到一共移动了7次盘子,也就是2^3-1那么可知64个盘子，我们需要移动2^64-1次盘子，由此可知这个任务的复杂度。大家现在只需要理解这种思维方式，如果有兴趣可以自己尝试<br>写一下代码。<br>从上面的两个问题，我们可以看到，使用递归函数,可以简化进关系。代码比较复杂，对现在的大家可能会很难，很痛苦，暂时我们不考虑学习。学习完整个课程以后，如果大家有兴趣可以自己去实现以下。</p>
<h2 id="递归应该如何实现"><a href="#递归应该如何实现" class="headerlink" title="递归应该如何实现"></a>递归应该如何实现</h2><p>1、<strong>基准条件</strong></p>
<p>什么叫基准条件?我们也可以理解为递归结束条件!如果没有结束条件， 就会出现死循环了，这点特别重要。<br>我们以<strong>阶乘</strong>为案例，如果我们在<strong>factorial</strong>函数中去掉</p>
<p>if (n == 1) {<br>    return 1;<br>}</p>
<p>最终代码为：</p>
<p>public static int factorial(int n) {<br>    return n * factorial(n - 1);<br>}</p>
<p>试想一下会出现什么问题？阶乘的结果将是</p>
<p>n! = n * (n - 1) * … * 1 * 0 * -1 * -2 * …</p>
<p>这将是一个<strong>死循环</strong>。<br>所以上面if (n == 1)这个结束条件，或者叫做<strong>基准条件</strong>非常<br>重要。<br>那汉诺塔问题的基准条件是什么呢?<br>同样的道理， 是第64个和尚处理最上面一个盘子的逻辑。</p>
<h3 id="2-递归公式"><a href="#2-递归公式" class="headerlink" title="2.递归公式"></a>2.递归公式</h3><p>解决了递归<strong>基准条件</strong>之后，我们需要考虑递归如何执行下去?<br>也就是递归公式。<br>对于阶乘的递归公式很容易找寻<br>                       <strong>f(n)=n<em>f(n- 1)</em></strong><br><strong>递归公式总是 描述自己和下一个递归函数直接的递进关系</strong><br><strong>那汉诺塔的递归公式是什么呢?</strong><br>第一个和尚的递归公式，应该是如果把上面63个盘子，当<br>做一个盘子，应该怎么搬运。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>所以在之后碰到问题以后，我们可以按照如下流程进行思考:<br>(1)找出<strong>基准条件</strong>。<br>(2)思考在基准条件下，会出现什么<strong>情况</strong>。<br>(3)思考基准条件<strong>前一步</strong>的情况，或者函数执行情况。<br>(4)配合<strong>递归公式</strong>，继续<strong>往前推进</strong>。<br>(5)最后实现完善的代码。❸<br>我们来实践几道题目，巩固一下递归能力。</p>
<h2 id="斐波那契数列的排列例题-代码案例："><a href="#斐波那契数列的排列例题-代码案例：" class="headerlink" title="斐波那契数列的排列例题-代码案例："></a>斐波那契数列的排列例题-代码案例：</h2><p>在数学中，有一种数列叫斐波那契数列的排列。如:<br>0，1，1，2，3，5，8，13，21，34，55，89，….|以此类推<br>下去。<br>我们想获取第N个斐波那契数应该怎么用代码实现呢?<br>从上面的例子我们发现，<strong>第三个数字开始每个数总是等于前面</strong><br><strong>两个数的和。</strong><br>从这个规律，可以得到:<br><strong>基准条件</strong><br>第0， 1个元素是0和1<br><strong>递归公式</strong><br><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/PY1/10/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.youkeda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recursive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>)+fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"fibonacci(1) = "</span> + fibonacci(<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">"fibonacci(3) = "</span> + fibonacci(<span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">"fibonacci(10) = "</span> + fibonacci(<span class="number">10</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="分治思想"><a href="#分治思想" class="headerlink" title="分治思想"></a>分治思想</h2><p>举个例子:<br>我们从小到大读书期间，学校为了方便学生管理，会将学生分为<strong>多个年级</strong>，每个年级又会分为<strong>多个班级</strong>，每个班级甚至还会分为<strong>很多小组</strong>。那疫情期间，学校有统计任务了,需要统计每 个同学包括其家人的籍贯，出行情况，那该如何做呢?我们知道，学校将任务分配给每个年级主任，年级主任分配给每个班级,每个班主任分配给每个组长，每个组长在分配给每个人。后在反过来一层层汇总学生信息，-级级反馈给上级。</p>
<p>这就是一个经典的分支案例，如果用计算机语言来描述的话:</p>
<p>分而治之的思想是采用了<strong>递归</strong>的思想,将原问题分成<strong>几个规模较小但是类似于原问题的子问题</strong>，通过递归的方式来求解这些小问题，最后将子问题的解合并来得到原问题的解。</p>
<p><img src="https://style.youkeda.com/img/course/a1/5/4-1.svg" alt></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>利用<strong>分治思想</strong>，我们可以实现一种更高效的排序算法—<strong>归并排序</strong>。<br>归并排序的核心思路<br>将大数组分解成小数组,将悔个小数组排好序，再将这些有<br>序的小数组合并成大数组。➊<br>我们来看一个具体案例，仍然用之前的数组</p>
<p>9, 2, 4, 7, 5, 3</p>
<p><img src="https://style.youkeda.com/img/course/a1/5/4-2.svg" alt></p>
<p>从图中，我们可以看出，我们分为如下几步：</p>
<p><strong>一、分</strong><br>2分法拆分原数组，直到每个数组里面只剩一个元素位置<br>(1)<strong>9，2，4，7，5，3</strong>拆分为<strong>9，2，4</strong>和<strong>7，5，3</strong>。<br>(2)<strong>9，2，4</strong>拆分为<strong>9,2</strong>和<strong>4</strong>，右侧数组也一样。<br>(3)<strong>9，2</strong>拆分为<strong>9和2</strong>。<br><strong>二、治</strong><br>将拆分的数组进行合并，并且在合并的时候保证合并的数组<br>是有序的。<br>(1)<strong>9和2</strong>，合并为<strong>2, 9</strong>，我们暂时只关心左侧部分。<br>(2)<strong>2，9</strong>和<strong>4</strong>，合并为<strong>2，4,9</strong>。<br>(3)|<strong>2，4，9</strong>和<strong>3，5，7</strong>，合并为<strong>2，3，4，5，7，9</strong>。</p>
<p><strong>分-代码实现</strong><br>在拆分的过程中，有两个核心逻辑<br><strong>1.如何递归进行数组的拆分</strong><br><strong>2.如何用原始数组创建两个子数组</strong><br>我们两个函数来表示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序， 返回排好序的数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line"><span class="comment">//拷贝原数组的部分内容，从left到right</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] subArray(<span class="keyword">int</span>[] source, <span class="keyword">int</span> left,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来,我们首先完成第二个函数,拷贝原数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝原数组的部分内容，从 left 到 right</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] subArray(<span class="keyword">int</span>[] source, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">    <span class="comment">// 创建一个新数组</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[right - left];</span><br><span class="line">    <span class="comment">// 依次赋值进去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">        result[i - left] = source[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分逻辑比较简单,我就不多加介绍了，重点看来mergesort:，如何实现递归拆分原数组。<br>我们先找准基准条件:<strong>数组元素只有一一个，则直接返回</strong>。代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序，返回排好序的数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">  <span class="keyword">if</span>(array.length == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在数组元素不止一个的情况下，我们需要从数组中间进行拆分，分别调用<strong>mergeSort</strong>，代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.youkeda;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 归并排序，返回排好序的数组</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="comment">// 为了方便查看结果，我们将每个数组进行打印</span></span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> middle = array.length / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 处理 0 到 middle 左侧数组部分</span></span><br><span class="line">    <span class="keyword">int</span>[] left = mergeSort(subArray(array, <span class="number">0</span>, middle));</span><br><span class="line">    <span class="comment">// 处理 middle 到 array.length 右侧数组部分</span></span><br><span class="line">    <span class="keyword">int</span>[] right = mergeSort(subArray(array, middle, array.length));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TODO处理合并问题</span></span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝原数组的部分内容，从 left 到 right</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] subArray(<span class="keyword">int</span>[] source, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">    <span class="comment">// 创建一个新数组</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[right - left];</span><br><span class="line">    <span class="comment">// 依次赋值进去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">      result[i - left] = source[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">// Arrays.toString 可以方便打印数组内容</span></span><br><span class="line">    System.out.println(<span class="string">"raw: "</span> + Arrays.toString(array));</span><br><span class="line">    <span class="keyword">int</span>[] result = mergeSort(array);</span><br><span class="line">    System.out.println(<span class="string">"result: "</span> + Arrays.toString(result));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家重点理解上面#1 #2 注释的代码，理解创建子数组，然.后递归分治的逻辑(我们暂时忽略合并排序的逻辑)<br>。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>快速排序</strong>：<strong>是现在编程语言自带排序函数中，使用的最多的算法。</strong><br>例如我们常见的 <strong>List. sort()</strong>。快速排序也是现在面试官最喜欢面试的排序的算法，没有之实现的原理、 复杂度都有一定的难度。那很多人不服了，为什么不是<strong>归并排序</strong>呢?<br>从上节课我们发现<strong>归并排序会创建新的数组，所以空间复杂度会偏大</strong>。同时在平时日常多见的平均情况下，快速排序确实在性能上表现优异多。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><strong>分区</strong><br>在归并排序中，我们会将数组二分解。<br>在快速排序中，分解的逻辑也差不多，首先我们随机选中一个数字当做轴，目标是将原始数组根据轴进行分区分拆，比轴小的放在左边，比轴大的放在右边。</p>
<p>那如何做到一点呢?我们来实战一-下,一步步实现。首先我们给定一个原始数组<br>1，6，4，2，5，3。<br>第一步,我们选择哪个数字为轴呢?理论上选择任意值都可以，那我们就以最后一个元愫3作为轴吧(选择轴本身是一定的技巧和方法,此处我们只考虑简单的情况，大家有精力的可以自己去研究)。</p>
<p>紧接着,我们放置左右两个指针，分别指向索引0和索弓|倒数<br>第二个，如图所示:</p>
<p><img src="https://style.youkeda.com/img/course/a1/5/5-2.svg" alt></p>
<p>紧接着我们需要将除3以外的剩下数字进行分区，分配到小于3和大于3两部分。<br>主要逻辑如下:<br>(1)左指针依次往右侧移动，当遇到大于或者等于轴3的值，则停止<br>(2)右指针相反，依次往左侧移动，当遇到小于或者等于轴3的值,则停止<br>(3)将左右两个指针指向的值进行互换<br>(4)互换以后，然后继续按照上面(1) - (3) 执行，直到左指针和右指针重叠。<br>(5)将左右两个指针指向的值和轴3互换我们还是一步步演示一下。</p>
<p><strong>第一步</strong><br>首先执行(1) (2) 两步，那最终指针停留在如下图所示，左指针指向6 |,右指针指向2。</p>
<p><img src="https://style.youkeda.com/img/course/a1/5/5-3.svg" alt></p>
<p>从图中，我们看到紧接着交换左右指针指向的值(也就是交换6和2的位置)。<br><strong>第二步</strong><br>我们继续推进左指针和右指针，左指针移动到4停止，右指针也是左移到4停止，这时候我们发现左右指针重合了。所以接下来需要执行(5)步骤,让4和轴3进行交换,如下图所示:</p>
<p><img src="https://style.youkeda.com/img/course/a1/5/5-4.svg" alt></p>
<p>从图中可以看出，这时候轴3，已经在它正确的位置。虽然3左边和3右边还是乱序，但-步步来嘛。<br>下面我们开始<strong>第二次分区。</strong><br>通过第一次分区 ，我们将数组分为左侧和右侧两部分，按照递归的思想，我们继续将左右两侧数组按照选轴分区重复排序。</p>
<p><img src="https://style.youkeda.com/img/course/a1/5/5-5.svg" alt></p>
<p>总结下，其实快速排序的宗旨<br>通过每次轴分区 ，都能完成轴的位置定位。<br><strong>时间复杂度</strong><br>那快速排序的时间复杂度是多少呢?和归并排序一样,每一-次分区需要全数组比较一次所以为0(N)。那需要多少次分区呢，按照二分法排序法应该为0(1og(N)) ,所以最终的结果为<strong>0(Nlog(N))。</strong><br>但是有一-种最坏的情况，如果元素的数组本身是有序的，大家想想会发生什么情况?如下图所示</p>
<p><img src="https://style.youkeda.com/img/course/a1/5/5-6.svg" alt></p>
<p>我们每次分区，实际.上相当于没有分区，因为轴永远是最大的值，这种情况下的时间复杂度是<strong>0(N^2</strong>)但这种情况是极少了，所以一般我们忽略,大家只需要了解一下最坏情况即可。</p>
<h2 id="快速排序代码实现"><a href="#快速排序代码实现" class="headerlink" title="快速排序代码实现"></a>快速排序代码实现</h2><p>在准备将算法用代码实现的时候，我们得特别注意总分的思想，不要一开始就去死抠细.<br>节。<br>比如在此处，我们得站在高处想一想， 我们的算法逻辑可以分为几个大块?<br>首先，我们知道<strong>快速排序</strong>是一个递归思维，那么知道是递归思维，我们需要知道<strong>基准条件</strong><br>和<strong>递归公式</strong>到底是什么?<br>这个递归比较简单，分别是</p>
<p><strong>基准条件</strong>:当数组里元素于等于1个元素的时候结束<br><strong>递归公式</strong>:当海一-次分区,获取到轴位置后，左右分拆数组，继续快速排序，这就是<br>递归公式。<br>好，有了这里概括，我们来写一些代码的思路。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.youkeda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速排序</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用快速排序的核心，传入left，right</span></span><br><span class="line">    quickSortCore(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速排序的核心，同样也是递归函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortCore</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归基准条件，left &gt;= right 即表示数组只有1个或者0个元素。</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据轴分区</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(array, left, right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用左侧和右侧数组分区</span></span><br><span class="line">    quickSortCore(array, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    quickSortCore(array, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对数组进行分区，并返回当前轴所在的位置</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">// Arrays.toString 可以方便打印数组内容</span></span><br><span class="line">    System.out.println(<span class="string">"raw: "</span> + Arrays.toString(array));</span><br><span class="line">    quickSort(array);</span><br><span class="line">    System.out.println(<span class="string">"result: "</span> + Arrays.toString(array));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么有了quickSortCore 还需要定义quickSort方法?因为为了方便外部调用，外部调用排序，只需要传入数组就行了，环需要再传入left，I right 。<br>这其实是接口友好的一种设计表现。➊在这里大家重点需要关心是整体实现思路。一定要掌握喔。接下来，请大家利用上一节学习的指针移动交换的逻辑，完成<strong>partition</strong>方法。</p>
<h1 id="快速排序代码案例："><a href="#快速排序代码案例：" class="headerlink" title="快速排序代码案例："></a>快速排序代码案例：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.youkeda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速排序</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用快速排序的核心，传入left，right</span></span><br><span class="line">    quickSortCore(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速排序的核心，同样也是递归函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortCore</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归基准条件，left &gt;= right 即表示数组只有1个或者0个元素。</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据轴分区</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(array, left, right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用左侧和右侧数组分区</span></span><br><span class="line">    quickSortCore(array, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    quickSortCore(array, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对数组进行分区，并返回当前轴所在的位置</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = array[right];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftIndex = left;</span><br><span class="line">    <span class="keyword">int</span> rightIndex = right - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 左指针移动</span></span><br><span class="line">      <span class="keyword">while</span> (array[leftIndex] &lt;= pivot &amp;&amp; leftIndex &lt; right) &#123;</span><br><span class="line">        leftIndex++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 右指针移动</span></span><br><span class="line">      <span class="keyword">while</span> (array[rightIndex] &gt;= pivot &amp;&amp; rightIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        rightIndex--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (leftIndex &gt;= rightIndex) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        swap(array, leftIndex, rightIndex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(array, leftIndex, right);</span><br><span class="line">    <span class="keyword">return</span> leftIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[index1];</span><br><span class="line">    array[index1] = array[index2];</span><br><span class="line">    array[index2] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">// Arrays.toString 可以方便打印数组内容</span></span><br><span class="line">    System.out.println(<span class="string">"raw: "</span> + Arrays.toString(array));</span><br><span class="line">    quickSort(array);</span><br><span class="line">    System.out.println(<span class="string">"result: "</span> + Arrays.toString(array));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序应用-快速选择-代码案例："><a href="#快速排序应用-快速选择-代码案例：" class="headerlink" title="快速排序应用 - 快速选择##     代码案例："></a>快速排序应用 - 快速选择##     代码案例：</h2><p><img src="https://style.youkeda.com/img/course/a1/5/5-7.svg" alt></p>
<p><strong>目标是找寻到30位同学成绩中，第6位同学的成绩!如果大家能顺利完成此处的代码，大家对快速排序已经真正的掌握了。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.youkeda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速选择，返回选中的元素</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quickFind</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用快速选择的核心，传入left，right</span></span><br><span class="line">    <span class="keyword">return</span> quickFindCore(array, aim, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速选择的核心，同样也是递归函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quickFindCore</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> aim, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归基准条件，left &gt;= right 即表示数组只有1个或者0个元素，返回当前的元素</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">      <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据轴分区</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(array, left, right);</span><br><span class="line">    <span class="comment">// 根据 aim 确定继续递归的方向</span></span><br><span class="line">    <span class="keyword">if</span> (pivotIndex &gt; aim) &#123;</span><br><span class="line">      <span class="keyword">return</span> quickFindCore(array, aim, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivotIndex &lt; aim) &#123;</span><br><span class="line">      <span class="keyword">return</span> quickFindCore(array, aim, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> array[pivotIndex];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对数组进行分区，并返回当前轴所在的位置</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = array[right];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftIndex = left;</span><br><span class="line">    <span class="keyword">int</span> rightIndex = right - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 左指针移动</span></span><br><span class="line">      <span class="keyword">while</span> (array[leftIndex] &lt; pivot &amp;&amp; leftIndex &lt; right) &#123;</span><br><span class="line">        leftIndex++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 右指针移动</span></span><br><span class="line">      <span class="keyword">while</span> (array[rightIndex] &gt; pivot &amp;&amp; rightIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        rightIndex--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (leftIndex &gt;= rightIndex) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        swap(array, leftIndex, rightIndex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(array, leftIndex, right);</span><br><span class="line">    <span class="keyword">return</span> leftIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[index1];</span><br><span class="line">    array[index1] = array[index2];</span><br><span class="line">    array[index2] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = &#123;<span class="number">72</span>, <span class="number">77</span>, <span class="number">48</span>, <span class="number">17</span>, <span class="number">71</span>, <span class="number">2</span>, <span class="number">25</span>, <span class="number">97</span>, <span class="number">82</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">18</span>, <span class="number">15</span>, <span class="number">57</span>, <span class="number">7</span>, <span class="number">48</span>, <span class="number">93</span>, <span class="number">47</span>, <span class="number">38</span>, <span class="number">74</span>, <span class="number">18</span>, <span class="number">93</span>, <span class="number">98</span>, <span class="number">41</span>, <span class="number">54</span>, <span class="number">4</span>, <span class="number">47</span>, <span class="number">4</span>, <span class="number">63</span>, <span class="number">76</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">"raw: "</span> + Arrays.toString(array));</span><br><span class="line">    <span class="comment">// 目标是倒数第 6 个元素</span></span><br><span class="line">    <span class="keyword">int</span> result = quickFind(array, array.length - <span class="number">6</span>);</span><br><span class="line">    System.out.println(<span class="string">"result: "</span> + result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/28/day19/" data-id="ckdtk5si0000jc4uxhmy7epm3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E5%BD%92%E3%80%81%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/" rel="tag">递归、分治思想-归并排序、快速排序、快速选择</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/08/02/day20/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          day20
        
      </div>
    </a>
  
  
    <a href="/2020/07/28/day18/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">day18</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS%E5%AE%9A%E4%BD%8D%EF%BC%88float%EF%BC%89%E6%A8%A1%E6%80%81%E6%A1%86-%E6%90%9C%E7%B4%A2%E6%A1%86/" rel="tag">CSS定位（float）模态框 搜索框</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS%E8%A3%85%E9%A5%B0-cutsor/" rel="tag">CSS装饰-cutsor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5-CSS3J%E4%BB%8B%E7%BB%8D-CSS%E4%BC%AA%E7%B1%BB%EF%BC%88after-before%E3%80%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E3%80%81%E4%BA%8B%E4%BB%B6%E4%BC%AA%E7%B1%BB%E3%80%81%E5%88%97%E8%A1%A8%E4%BC%AA%E7%B1%BB%E3%80%81%E5%BE%AE%E5%8D%9A%E5%A4%B4%E9%83%A8%E5%BC%80%E5%8F%91%EF%BC%89/" rel="tag">HTML5/CSS3J介绍 CSS伪类（after/before、清除浮动、事件伪类、列表伪类、微博头部开发）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Response-%E7%BD%91%E9%A1%B5-Response-%E9%9D%9E%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6-Response-JSON/" rel="tag">Java网络编程 Response-网页 Response-非文本文件 Response-JSON</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SMTP%E3%80%81javaMail%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E3%80%81%E5%AE%9E%E6%88%98%E5%A4%A9%E6%B0%94/" rel="tag">SMTP、javaMail邮件发送、实战天气</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/User-Agent%E3%80%81Referer%E3%80%81Host/" rel="tag">User-Agent、Referer、Host</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css-%E5%AE%9A%E4%BD%8D-position/" rel="tag">css 定位- position</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css%E7%9B%92%E6%A8%A1%E5%9E%8B/" rel="tag">css盒模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-GET%E8%AF%B7%E6%B1%82/" rel="tag">java网络编程   GET请求</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/" rel="tag">java面向对象-项目实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/list%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2%E4%BB%A5%E5%8F%8A-%E9%9B%86%E5%90%88List%E7%9A%84%E6%93%8D%E4%BD%9C/" rel="tag">list和数组的转换以及 集合List的操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%9B%BE%E7%89%87%E3%80%81%E8%A7%A3%E6%9E%90excel%E3%80%81cookie%E3%80%81session%E3%80%81%E5%A4%8D%E7%94%A8session/" rel="tag">下载文件图片、解析excel、cookie、session、复用session</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" rel="tag">冒泡排序、选择排序、插入排序、二分插入排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E4%BA%91/" rel="tag">图云</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E6%88%98%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/" rel="tag">实战网易云音乐</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B0%8F%E6%A1%88%E4%BE%8B-%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E3%80%81-%E4%BA%8C%E6%AC%A1%E9%97%AE%E9%A2%98%EF%BC%88%E6%A0%87%E8%AE%B0%E6%B3%95%EF%BC%89%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%81-%E6%95%B0%E7%BB%84-%E5%AD%98%E5%82%A8%E5%92%8C%E8%AF%BB%E5%8F%96%E3%80%81%E6%95%B0%E7%BB%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4/" rel="tag">性能优化小案例-二分法查找、 二次问题（标记法）、计算机内存管理、 数组-存储和读取、数组插入和删除</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%89%8D%E8%A8%80%E3%80%81-%E5%A4%A7O%E8%AE%B0%E6%B3%95%E3%80%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" rel="tag">数据结构及算法入门前言、 大O记法、时间复杂度、空间复杂度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2%E3%80%81-%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/" rel="tag">背景颜色、 背景图片</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E5%BD%92%E3%80%81%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/" rel="tag">递归、分治思想-归并排序、快速排序、快速选择</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS%E5%AE%9A%E4%BD%8D%EF%BC%88float%EF%BC%89%E6%A8%A1%E6%80%81%E6%A1%86-%E6%90%9C%E7%B4%A2%E6%A1%86/" style="font-size: 10px;">CSS定位（float）模态框 搜索框</a> <a href="/tags/CSS%E8%A3%85%E9%A5%B0-cutsor/" style="font-size: 10px;">CSS装饰-cutsor</a> <a href="/tags/HTML5-CSS3J%E4%BB%8B%E7%BB%8D-CSS%E4%BC%AA%E7%B1%BB%EF%BC%88after-before%E3%80%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E3%80%81%E4%BA%8B%E4%BB%B6%E4%BC%AA%E7%B1%BB%E3%80%81%E5%88%97%E8%A1%A8%E4%BC%AA%E7%B1%BB%E3%80%81%E5%BE%AE%E5%8D%9A%E5%A4%B4%E9%83%A8%E5%BC%80%E5%8F%91%EF%BC%89/" style="font-size: 10px;">HTML5/CSS3J介绍 CSS伪类（after/before、清除浮动、事件伪类、列表伪类、微博头部开发）</a> <a href="/tags/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Response-%E7%BD%91%E9%A1%B5-Response-%E9%9D%9E%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6-Response-JSON/" style="font-size: 10px;">Java网络编程 Response-网页 Response-非文本文件 Response-JSON</a> <a href="/tags/SMTP%E3%80%81javaMail%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E3%80%81%E5%AE%9E%E6%88%98%E5%A4%A9%E6%B0%94/" style="font-size: 10px;">SMTP、javaMail邮件发送、实战天气</a> <a href="/tags/User-Agent%E3%80%81Referer%E3%80%81Host/" style="font-size: 10px;">User-Agent、Referer、Host</a> <a href="/tags/css-%E5%AE%9A%E4%BD%8D-position/" style="font-size: 10px;">css 定位- position</a> <a href="/tags/css%E7%9B%92%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">css盒模型</a> <a href="/tags/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-GET%E8%AF%B7%E6%B1%82/" style="font-size: 10px;">java网络编程   GET请求</a> <a href="/tags/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/" style="font-size: 10px;">java面向对象-项目实战</a> <a href="/tags/list%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2%E4%BB%A5%E5%8F%8A-%E9%9B%86%E5%90%88List%E7%9A%84%E6%93%8D%E4%BD%9C/" style="font-size: 10px;">list和数组的转换以及 集合List的操作</a> <a href="/tags/%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%9B%BE%E7%89%87%E3%80%81%E8%A7%A3%E6%9E%90excel%E3%80%81cookie%E3%80%81session%E3%80%81%E5%A4%8D%E7%94%A8session/" style="font-size: 10px;">下载文件图片、解析excel、cookie、session、复用session</a> <a href="/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">冒泡排序、选择排序、插入排序、二分插入排序</a> <a href="/tags/%E5%9B%BE%E4%BA%91/" style="font-size: 10px;">图云</a> <a href="/tags/%E5%AE%9E%E6%88%98%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/" style="font-size: 10px;">实战网易云音乐</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B0%8F%E6%A1%88%E4%BE%8B-%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E3%80%81-%E4%BA%8C%E6%AC%A1%E9%97%AE%E9%A2%98%EF%BC%88%E6%A0%87%E8%AE%B0%E6%B3%95%EF%BC%89%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%81-%E6%95%B0%E7%BB%84-%E5%AD%98%E5%82%A8%E5%92%8C%E8%AF%BB%E5%8F%96%E3%80%81%E6%95%B0%E7%BB%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4/" style="font-size: 10px;">性能优化小案例-二分法查找、 二次问题（标记法）、计算机内存管理、 数组-存储和读取、数组插入和删除</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E5%89%8D%E8%A8%80%E3%80%81-%E5%A4%A7O%E8%AE%B0%E6%B3%95%E3%80%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" style="font-size: 10px;">数据结构及算法入门前言、 大O记法、时间复杂度、空间复杂度</a> <a href="/tags/%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2%E3%80%81-%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/" style="font-size: 10px;">背景颜色、 背景图片</a> <a href="/tags/%E9%80%92%E5%BD%92%E3%80%81%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/" style="font-size: 10px;">递归、分治思想-归并排序、快速排序、快速选择</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/13/day31/">day31</a>
          </li>
        
          <li>
            <a href="/2020/08/11/day30/">day30</a>
          </li>
        
          <li>
            <a href="/2020/08/11/day28/">day28</a>
          </li>
        
          <li>
            <a href="/2020/08/10/day27/">day27</a>
          </li>
        
          <li>
            <a href="/2020/08/08/day26/">day26</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>